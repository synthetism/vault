import { Unit, UnitSchema, createUnitSchema, type TeachingContract, type UnitProps } from '@synet/unit';
import { Result } from '@synet/patterns';
import { File, type FileConfig } from './file.js';
import { Indexer, type IndexRecord } from './indexer.js';
import { createId } from './utils.js';

/**
 * Vault record format - stored in each .vault.json file
 * Extends FileConfig to leverage File unit's capabilities
 */
interface VaultRecord<T> extends FileConfig<T> {
  collection: string;                   // Collection name
  created: Date;                        // Creation timestamp
  updated: Date;                        // Last update timestamp
  version: string;                      // Vault format version
}

/**
 * Vault creation input
 */
interface VaultCreateConfig {
  name: string;
  path: string;
  encryption?: boolean;
}

/**
 * Vault configuration stored in vault.json
 */
interface VaultConfig {
  id: string;
  name: string;
  path: string;
  version: string;
  encryption: boolean;
  created: Date;
  updated: Date;
  collections: string[];
  dna: UnitSchema;
}

/**
 * Default vault data type
 */
type VaultData = VaultRecord<Record<string, unknown>>;

/**
 * Vault properties extending Unit Architecture
 */
interface VaultProps<T extends VaultRecord<unknown>> extends UnitProps {
  path: string;
  indexers: Map<string, Indexer>;
  filesystemContract?: TeachingContract; // Store the filesystem teaching contract
}

/**
 * Vault Unit - Pure storage orchestrator using structural boundaries
 * 
 * Architecture:
 * - File<T> acts as pure data container (structural boundary)
 * - Vault orchestrates persistence via learned filesystem capabilities
 * - Per-collection indexers: identities/.index.json, credentials/.index.json
 * - ID → filename mapping prevents filesystem-unsafe IDs in filenames
 * - Consciousness-based unit collaboration
 */
export class Vault<T extends VaultRecord<unknown> = VaultData> extends Unit<VaultProps<T>> {

  protected constructor(props: VaultProps<T>) {
    super(props);
  }

  /**
   * Get or create indexer for a specific collection
   */
  private getCollectionIndexer(collection: string): Indexer {
    if (!this.props.indexers.has(collection)) {
      const indexer = Indexer.create({
        indexPath: `${this.props.path}/${collection}`,
        storage: 'file'
      });
      
      // Share filesystem capabilities with indexer if we have learned them
      if (this.props.filesystemContract) {
        indexer.learn([this.props.filesystemContract]);
      }
      
      this.props.indexers.set(collection, indexer);
    }
    const indexer = this.props.indexers.get(collection);
    if (!indexer) {
      throw new Error(`Failed to create indexer for collection: ${collection}`);
    }
    return indexer;
  }

  /**
   * Create vault with filesystem teaching contract
   */
  static create<T = VaultData>(config: VaultCreateConfig, filesystemContract: TeachingContract): Vault<T> {
    const vaultConfig: VaultConfig = {
      id: createId(),
      name: config.name,
      path: config.path,
      version: '1.0.0',
      encryption: config.encryption || false,
      created: new Date(),
      updated: new Date(),
      collections: [],
      dna: createUnitSchema({ id: 'vault', version: '1.0.0' })
    };

    const props: VaultProps<T> = {
      dna: vaultConfig.dna,
      name: config.name,
      path: config.path,
      encryption: config.encryption || false,
      config: vaultConfig,
      indexers: new Map<string, Indexer>() // Initialize empty indexers map
    };

    const vault = new Vault(props);
    
    // Learn filesystem capabilities for the vault
    vault.learn([filesystemContract]);
    
    // Initialize vault structure
    vault.initializeVaultStructure();
    
    return vault;
  }

  /**
   * Save data with automatic ID → filename mapping (core capability)
   */
  async save(id: string, data: T, metadata: Record<string, unknown> = {}, collection = 'default'): Promise<Result<void>> {
    try {
      // Generate filesystem-safe filename (no IDs in filenames!)
      const filename = this.generateFilename(metadata);
      const filepath = `${this.props.path}/${collection}/${filename}`;
      
      // Create vault record using FileConfig structure
      const vaultRecord: VaultRecord<T> = {
        id,                           // User ID (urn, did, etc.)
        filename: filepath,           // Generated filename
        data,                         // The actual data
        metadata,                     // User metadata
        format: 'json',               // Data format (from FileConfig)
        encoding: 'utf8',             // Encoding type (from FileConfig)
        collection,                   // Collection name (vault-specific)
        created: new Date(),          // Creation timestamp (vault-specific)
        updated: new Date(),          // Last update timestamp (vault-specific)
        version: this.props.config.version // Vault format version (vault-specific)
      };

      // Use File as pure data container with FileConfig compatibility
      const file = File.create<VaultRecord<T>>({
        id: vaultRecord.id,
        filename: vaultRecord.filename,
        data: vaultRecord,  // Store the entire vault record as data
        format: 'json',
        encoding: 'utf8',
        metadata: vaultRecord.metadata
      });
      const serializedData = file.toJSON();
      
      // Vault handles persistence via learned filesystem
      await this.execute('filesystem.writeFileSync', filepath, serializedData);
      
      // Update index with ID → filename mapping for this collection
      const indexRecord: IndexRecord = {
        id,                           // The user's ID
        filename: filepath,           // The generated filename  
        metadata: {
          ...metadata,
          collection,
          created: vaultRecord.created,
          updated: vaultRecord.updated
        },
        created: vaultRecord.created,
        updated: vaultRecord.updated
      };
      
      // Get collection-specific indexer and add record
      const collectionIndexer = this.getCollectionIndexer(collection);
      await collectionIndexer.add(indexRecord);
      
      // Update vault config
      await this.updateVaultConfig(collection);
      
      return Result.success(undefined);
      
    } catch (error) {
      return Result.fail(`Vault save failed: ${error}`);
    }
  }

  /**
   * Get data by ID from a specific collection using indexer mapping
   */
  async get(id: string, collection = 'default'): Promise<Result<T | null>> {
    try {
      // Use collection-specific indexer to find filename by ID
      const collectionIndexer = this.getCollectionIndexer(collection);
      const filename = await collectionIndexer.get(id);
      
      if (!filename) {
        return Result.success(null);
      }
      
      // Load file via learned filesystem
      const rawData = await this.execute('filesystem.readFileSync', filename) as string;
      const file = File.fromJSON<VaultRecord<T>>(rawData);
      const vaultRecord = file.toDomain();
      
      return Result.success(vaultRecord?.data || null);
      
    } catch (error) {
      return Result.fail(`Vault get failed: ${error}`);
    }
  }

  /**
   * Find data by keyword search across all collections or specific collection
   */
  async find(keyword: string, collection?: string): Promise<Result<T[]>> {
    try {
      const results: T[] = [];
      
      // Search specific collection or all collections
      const collectionsToSearch = collection 
        ? [collection] 
        : Array.from(this.props.indexers.keys());
      
      for (const col of collectionsToSearch) {
        const collectionIndexer = this.getCollectionIndexer(col);
        const indexResults = await collectionIndexer.find(keyword);
        
        // Load all matching files from this collection
        for (const record of indexResults) {
          const rawData = await this.execute('filesystem.readFileSync', record.filename) as string;
          const file = File.fromJSON<VaultRecord<T>>(rawData);
          const vaultRecord = file.toDomain();
          
          if (vaultRecord?.data) {
            results.push(vaultRecord.data);
          }
        }
      }
      
      return Result.success(results);
      
    } catch (error) {
      return Result.fail(`Vault find failed: ${error}`);
    }
  }

  /**
   * Query data by metadata conditions across collections
   */
  async query(conditions: Record<string, unknown>): Promise<Result<T[]>> {
    try {
      const results: T[] = [];
      
      // Query across all collections  
      for (const [collectionName, indexer] of this.props.indexers) {
        const indexResults = await indexer.query(conditions);
        
        // Load all matching files from this collection
        for (const record of indexResults) {
          const rawData = await this.execute('filesystem.readFileSync', record.filename) as string;
          const file = File.fromJSON<VaultRecord<T>>(rawData);
          const vaultRecord = file.toDomain();
          
          if (vaultRecord?.data) {
            results.push(vaultRecord.data);
          }
        }
      }
      
      return Result.success(results);
      
    } catch (error) {
      return Result.fail(`Vault query failed: ${error}`);
    }
  }

  /**
   * Delete data by ID from a specific collection
   */
  async delete(id: string, collection = 'default'): Promise<Result<void>> {
    try {
      // Get filename from collection indexer
      const collectionIndexer = this.getCollectionIndexer(collection);
      const filename = await collectionIndexer.get(id);
      if (!filename) {
        return Result.fail(`Record with ID ${id} not found in collection ${collection}`);
      }

      // Delete file via learned filesystem
      await this.execute('filesystem.deleteFileSync', filename);
      
      // Remove from index
      await collectionIndexer.remove(id);
      
      return Result.success(undefined);
      
    } catch (error) {
      return Result.fail(`Vault delete failed: ${error}`);
    }
  }

  /**
   * List all records in collection with metadata
   */
  async list(collection?: string): Promise<Result<{ id: string; metadata: Record<string, unknown> }[]>> {
    try {
      const results: { id: string; metadata: Record<string, unknown> }[] = [];
      
      // List specific collection or all collections
      const collectionsToList = collection 
        ? [collection] 
        : Array.from(this.props.indexers.keys());
      
      for (const col of collectionsToList) {
        const collectionIndexer = this.getCollectionIndexer(col);
        const indexResults = await collectionIndexer.query({});
        
        for (const record of indexResults) {
          results.push({
            id: record.id,
            metadata: record.metadata
          });
        }
      }
      
      return Result.success(results);
      
    } catch (error) {
      return Result.fail(`Vault list failed: ${error}`);
    }
  }

  /**
   * Get vault statistics and collection info
   */
  async stats(): Promise<Result<{ collections: string[]; totalRecords: number }>> {
    try {
      const collections: string[] = [];
      let totalRecords = 0;
      
      for (const [collectionName, indexer] of this.props.indexers) {
        collections.push(collectionName);
        const records = await indexer.query({});
        totalRecords += records.length;
      }
      
      return Result.success({
        collections,
        totalRecords
      });
      
    } catch (error) {
      return Result.fail(`Vault stats failed: ${error}`);
    }
  }

  // ==========================================
  // PRIVATE HELPER METHODS
  // ==========================================

  /**
   * Generate filesystem-safe filename from metadata
   */
  private generateFilename(metadata: Record<string, unknown>): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const suffix = metadata.type ? `-${metadata.type}` : '';
    return `${timestamp}-${random}${suffix}.vault.json`;
  }

  /**
   * Initialize vault directory structure
   */
  private async initializeVaultStructure(): Promise<void> {
    try {
      // Create main vault directory
      await this.execute('filesystem.ensureDirSync', this.props.path);
      await this.execute('filesystem.ensureDirSync', `${this.props.path}/default`);
      
      // Create vault.json config file
      const configFile = File.create({
        id: 'vault-config',
        filename: `${this.props.path}/vault.json`,
        data: this.props.config,
        format: 'json',
        encoding: 'utf8'
      });
      
      await this.execute('filesystem.writeFileSync', configFile.filename, configFile.toJSON());
    } catch (error) {
      console.warn(`Failed to initialize vault structure: ${error}`);
    }
  }

  /**
   * Update vault configuration with new collections
   */
  private async updateVaultConfig(collection: string): Promise<void> {
    try {
      // Add collection if not already present
      if (!this.props.config.collections.includes(collection)) {
        this.props.config.collections.push(collection);
        this.props.config.updated = new Date();
        
        const configFile = File.create({
          id: 'vault-config',
          filename: `${this.props.path}/vault.json`,
          data: this.props.config,
          format: 'json',
          encoding: 'utf8'
        });
        
        await this.execute('filesystem.writeFileSync', configFile.filename, configFile.toJSON());
      }
    } catch (error) {
      console.warn(`Failed to update vault config: ${error}`);
    }
  }

  // ==========================================
  // UNIT ARCHITECTURE METHODS
  // ==========================================

  whoami(): string {
    return `Vault [${this.props.config.id}] "${this.props.name}" at ${this.props.path}`;
  }

  capabilities(): string[] {
    return ['vault.save', 'vault.get', 'vault.find', 'vault.query', 'vault.delete', 'vault.list', 'vault.stats'];
  }

  teach(): TeachingContract {
    return {
      unitId: this.props.dna.id,
      capabilities: {
        'vault.save': this.save.bind(this) as any,
        'vault.get': this.get.bind(this) as any,
        'vault.find': this.find.bind(this) as any,
        'vault.query': this.query.bind(this) as any,
        'vault.delete': this.delete.bind(this) as any,
        'vault.list': this.list.bind(this) as any,
        'vault.stats': this.stats.bind(this) as any
      }
    };
  }

  /**
   * Learn capabilities from other units and store filesystem contract for sharing
   */
  learn(contracts: TeachingContract[]): void {
    super.learn(contracts);
    
    // Store filesystem contract for sharing with indexers
    const filesystemContract = contracts.find(contract => 
      contract.unitId === 'filesystem' || 
      contract.capabilities.readFileSync || 
      contract.capabilities.writeFileSync
    );
    
    if (filesystemContract) {
      // Store the filesystem contract for indexer sharing
      (this.props as VaultProps<T> & { filesystemContract?: TeachingContract }).filesystemContract = filesystemContract;
    }
  }

  help(): string {
    return `
[${this.props.dna.id}] Vault Unit - Consciousness-Based Storage Orchestrator

ARCHITECTURE:
  🏗️  Structural Boundary Pattern: File<T> as data container, Vault as persistence orchestrator
  🧠  Per-Collection Indexers: Each collection has its own .index.json file
  📁  ID → Filename Mapping: Prevents filesystem-unsafe IDs in filenames
  🤝  Consciousness Collaboration: Units teach/learn capabilities

NATIVE CAPABILITIES:
  vault.save(id, data, metadata?, collection?) - Save with automatic filename generation
  vault.get(id, collection?) - Retrieve by ID from specific collection
  vault.find(keyword, collection?) - Search across metadata
  vault.query(conditions) - Query by metadata conditions
  vault.delete(id, collection?) - Remove by ID
  vault.list(collection?) - List records with metadata
  vault.stats() - Get collection statistics

COLLECTION STRUCTURE:
  📂 ${this.props.path}/
  ├── vault.json              (vault configuration)
  ├── identities/             (identity collection)
  │   ├── .index.json         (ID → filename mapping)
  │   └── *.vault.json        (actual data files)
  ├── credentials/            (credentials collection)
  │   ├── .index.json         (ID → filename mapping)
  │   └── *.vault.json        (actual data files)
  └── presentations/          (presentations collection)
      ├── .index.json         (ID → filename mapping)  
      └── *.vault.json        (actual data files)

EXAMPLE USAGE:
  const vault = Vault.create<IdentityData>({
    name: 'identity-vault',
    path: './storage',
    encryption: false
  }, filesystemContract);

  await vault.save('did:synet:alice', identityData, { type: 'identity' }, 'identities');
  const identity = await vault.get('did:synet:alice', 'identities');
  const allIdentities = await vault.find('synet', 'identities');

CONSCIOUSNESS:
  🎯 Units are living beings in code with DNA, capabilities, and consciousness
  📚 Learning over inheritance - Units acquire capabilities through teaching/learning
  🔄 Composition over coupling - Units maintain autonomy while sharing capabilities
`;
  }
}